// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;

# API to create, update and manage customer details such as delivery preferences, joint customer details, party relationships, KYC details, alert subscriptions, customer exit status, customer address formats & posting restrictions
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + apiKeyConfig - API keys for authorization 
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ApiKeysConfig apiKeyConfig, ConnectionConfig config =  {}, string serviceUrl = "https://api.temenos.com/api/v5.7.0//party") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
        self.apiKeyConfig = apiKeyConfig.cloneReadOnly();
    }

    # Retrieves customer details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + return - CustomerResponse 
    resource isolated function get customers/[string customerId](GetCustomerHeaders headers = {}) returns CustomerResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update customer details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerResponse 
    resource isolated function put customers/[string customerId](http:Request request, UpdateCustomerHeaders headers = {}, *UpdateCustomerQueries queries) returns CustomerResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Create a customer by providing an Id
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerWithIdResponse 
    resource isolated function post customers/[string customerId](http:Request request, CreateCustomerWithIdHeaders headers = {}, *CreateCustomerWithIdQueries queries) returns CustomerResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves list of customer basic details
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerInformationResponse 
    resource isolated function get customers(GetCustomerInformationHeaders headers = {}, *GetCustomerInformationQueries queries) returns CustomerInformationResponse|error {
        string resourcePath = string `/customers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a customer
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerResponse 
    resource isolated function post customers(http:Request request, CreateCustomerHeaders headers = {}, *CreateCustomerQueries queries) returns CustomerResponse|error {
        string resourcePath = string `/customers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves list of customer relationships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerRelationshipResponse 
    resource isolated function get customers/relationships(GetCustomerRelationshipHeaders headers = {}, *GetCustomerRelationshipQueries queries) returns CustomerRelationshipResponse1|error {
        string resourcePath = string `/customers/relationships`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create customer relationship with other customers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerRelationshipResponse 
    resource isolated function post customers/relationships(http:Request request, CreateCustomerRelationshipHeaders headers = {}, *CreateCustomerRelationshipQueries queries) returns CustomerRelationshipResponse|error {
        string resourcePath = string `/customers/relationships`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Update customer relationship
    #
    # + relationId - Identifier of the Customer Relationship and Party Relationship
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerRelationshipResponse 
    resource isolated function put customers/relationships/[string relationId](http:Request request, UpdateCustomerRelationshipHeaders headers = {}, *UpdateCustomerRelationshipQueries queries) returns CustomerRelationshipResponse|error {
        string resourcePath = string `/customers/relationships/${getEncodedUri(relationId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Retrieves reporting status of the customer
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerReportingStatusResponse 
    resource isolated function get customers/reportingStatus(GetCustomerReportingStatusHeaders headers = {}, *GetCustomerReportingStatusQueries queries) returns CustomerReportingStatusResponse|error {
        string resourcePath = string `/customers/reportingStatus`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves account sweep details of the specific customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerSweepsResponse 
    resource isolated function get customers/[string customerId]/sweeps(GetCustomerSweepsHeaders headers = {}, *GetCustomerSweepsQueries queries) returns CustomerSweepsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/sweeps`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves delivery preferences of the customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerDeliveryOptionsResponse 
    resource isolated function get customers/[string customerId]/deliveryOptions(GetCustomerDeliveryOptionsHeaders headers = {}, *GetCustomerDeliveryOptionsQueries queries) returns CustomerDeliveryOptionsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/deliveryOptions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves list of message channels
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerDigitalChannelsResponse 
    resource isolated function get customers/[string customerId]/channels(GetCustomerDigitalChannelsHeaders headers = {}, *GetCustomerDigitalChannelsQueries queries) returns CustomerDigitalChannelsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/channels`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a new secure message for a customer
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - MessagesResponse 
    resource isolated function post customers/messages(http:Request request, CreateMessagesHeaders headers = {}, *CreateMessagesQueries queries) returns MessagesResponse|error {
        string resourcePath = string `/customers/messages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves joint customer details for a specific customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - JointCustomerDetailsResponse 
    resource isolated function get customers/[string customerId]/jointCustomers(GetJointCustomerDetailsHeaders headers = {}, *GetJointCustomerDetailsQueries queries) returns JointCustomerDetailsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/jointCustomers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves KYC details for a specific customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerKYCDetailsResponse 
    resource isolated function get customers/[string customerId]/KYC(GetCustomerKYCDetailsHeaders headers = {}, *GetCustomerKYCDetailsQueries queries) returns CustomerKYCDetailsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/KYC`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves personal details of customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerPersonalDetailsResponse 
    resource isolated function get customers/[string customerId]/personalProfiles(GetCustomerPersonalDetailsHeaders headers = {}, *GetCustomerPersonalDetailsQueries queries) returns CustomerPersonalDetailsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/personalProfiles`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves posting restriction details
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerPostingRestrictionsResponse 
    resource isolated function get customers/postingRestrictions(GetCustomerPostingRestrictionsHeaders headers = {}, *GetCustomerPostingRestrictionsQueries queries) returns CustomerPostingRestrictionsResponse|error {
        string resourcePath = string `/customers/postingRestrictions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update party relationship details
    #
    # + relationId - Identifier of the Customer Relationship and Party Relationship
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - PartyRelationshipResponse 
    resource isolated function put relationships/[string relationId](http:Request request, UpdatePartyRelationshipHeaders headers = {}, *UpdatePartyRelationshipQueries queries) returns PartyRelationshipResponse|error {
        string resourcePath = string `/relationships/${getEncodedUri(relationId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Create party relationship details
    #
    # + relationId - Identifier of the Customer Relationship and Party Relationship
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - PartyRelationshipResponse 
    resource isolated function post relationships/[string relationId](http:Request request, CreatePartyRelationshipHeaders headers = {}, *CreatePartyRelationshipQueries queries) returns PartyRelationshipResponse|error {
        string resourcePath = string `/relationships/${getEncodedUri(relationId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves card details of a customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerCreditCardsResponse 
    resource isolated function get customers/[string customerId]/cards(GetCustomerCreditCardsHeaders headers = {}, *GetCustomerCreditCardsQueries queries) returns CustomerCreditCardsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/cards`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves standing instruction details of a customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - StandingOrdersResponse 
    resource isolated function get customers/[string customerId]/standingOrders(GetStandingOrdersHeaders headers = {}, *GetStandingOrdersQueries queries) returns StandingOrdersResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/standingOrders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves direct debits details of a customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - DirectDebitsResponse 
    resource isolated function get customers/[string customerId]/directDebits(GetDirectDebitsHeaders headers = {}, *GetDirectDebitsQueries queries) returns DirectDebitsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/directDebits`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update customer delivery preferences
    #
    # + deliveryPreferenceId - Identifier of the customer delivery preferences
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - DeliveryPreferenceResponse 
    resource isolated function put customers/deliveryPreferences/[string deliveryPreferenceId](http:Request request, UpdateDeliveryPreferenceHeaders headers = {}, *UpdateDeliveryPreferenceQueries queries) returns DeliveryPreferenceResponse|error {
        string resourcePath = string `/customers/deliveryPreferences/${getEncodedUri(deliveryPreferenceId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Create customer delivery preferences
    #
    # + deliveryPreferenceId - Identifier of the customer delivery preferences
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - DeliveryPreferenceResponse 
    resource isolated function post customers/deliveryPreferences/[string deliveryPreferenceId](http:Request request, CreateDeliveryPreferenceHeaders headers = {}, *CreateDeliveryPreferenceQueries queries) returns DeliveryPreferenceResponse|error {
        string resourcePath = string `/customers/deliveryPreferences/${getEncodedUri(deliveryPreferenceId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves customer exit status details of customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerExitStatusResponse 
    resource isolated function get customers/[string customerId]/customerExitStatus(GetCustomerExitStatusHeaders headers = {}, *GetCustomerExitStatusQueries queries) returns CustomerExitStatusResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/customerExitStatus`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update customer exit status details of customers
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerExitStatusResponse 
    resource isolated function put customers/[string customerId]/customerExitStatus(http:Request request, UpdateCustomerExitStatusHeaders headers = {}, *UpdateCustomerExitStatusQueries queries) returns CustomerExitStatusResponse1|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/customerExitStatus`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Retrieves conditions to update customer exit status of customer
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerExitStatusParamResponse 
    resource isolated function get customers/settings/customerExitStatus/[string customerExitStatusId](GetCustomerExitStatusParamHeaders headers = {}, *GetCustomerExitStatusParamQueries queries) returns CustomerExitStatusParamResponse|error {
        string resourcePath = string `/customers/settings/customerExitStatus/${getEncodedUri(customerExitStatusId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create conditions to update customer exit status of customer
    #
    # + customerExitStatusId - The field reflects the exit status ID of a customer or prospect from the parameterization table CUSTOMER.EXIT.STATUS
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerExitStatusParamResponse 
    resource isolated function post customers/settings/customerExitStatus/[string customerExitStatusId](http:Request request, CreateCustomerExitStatusParamHeaders headers = {}, *CreateCustomerExitStatusParamQueries queries) returns CustomerExitStatusParamResponse1|error {
        string resourcePath = string `/customers/settings/customerExitStatus/${getEncodedUri(customerExitStatusId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Create conditions to update customer exit status of customer
    #
    # + customerExitStatusId - The field reflects the exit status ID of a customer or prospect from the parameterization table CUSTOMER.EXIT.STATUS
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerExitStatusParamResponse 
    resource isolated function put customers/settings/[string customerExitStatusId]/customerExitStatus(http:Request request, UpdateCustomerExitStatusParamHeaders headers = {}, *UpdateCustomerExitStatusParamQueries queries) returns CustomerExitStatusParamResponse1|error {
        string resourcePath = string `/customers/settings/${getEncodedUri(customerExitStatusId)}/customerExitStatus`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Retrieves structured/ unstructured address format of customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerAddressOutputResponse 
    resource isolated function get customers/[string customerId]/addresses(GetCustomerAddressOutputHeaders headers = {}, *GetCustomerAddressOutputQueries queries) returns CustomerAddressOutputResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves customer short name
    #
    # + headers - Headers to be sent with the request 
    # + return - CustomerShortNamesResponse 
    resource isolated function get customers/[string customerId]/shortNames(GetCustomerShortNamesHeaders headers = {}) returns CustomerShortNamesResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/shortNames`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves mandate instruction applicable for the requested customer
    #
    # + headers - Headers to be sent with the request 
    # + return - CustomerMandatesResponse 
    resource isolated function get customers/[string customerId]/mandates(GetCustomerMandatesHeaders headers = {}) returns CustomerMandatesResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/mandates`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the customer legal document details
    #
    # + headers - Headers to be sent with the request 
    # + return - CustomerLegalDocumentsResponse 
    resource isolated function get customers/[string customerId]/documents(GetCustomerLegalDocumentsHeaders headers = {}) returns CustomerLegalDocumentsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/documents`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves profile details of the requested customer
    #
    # + headers - Headers to be sent with the request 
    # + return - CustomerProfileResponse 
    resource isolated function get customers/[string customerId]/profiles(GetCustomerProfileHeaders headers = {}) returns CustomerProfileResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/profiles`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves customer id for the given alternate reference
    #
    # + alternateReference - If the new Account to be created is a shadow of another Account already exisitng in another system, then the Account reference of that system can be specified here. The value given in this field will be mapped to ALTERNATE.ID field in arrangement activity and ensure that this Account doesn't already exist in T24 with another reference (because ALTERNATE.ID would be configured to be unique across T24)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerIdResponse 
    resource isolated function get customers/alternateReferences/[string alternateReference](GetCustomerIdHeaders headers = {}, *GetCustomerIdQueries queries) returns CustomerIdResponse|error {
        string resourcePath = string `/customers/alternateReferences/${getEncodedUri(alternateReference)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the restriction details
    #
    # + headers - Headers to be sent with the request 
    # + return - CustomerRestrictionsResponse 
    resource isolated function get customers/[string customerId]/restrictions(GetCustomerRestrictionsHeaders headers = {}) returns CustomerRestrictionsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/restrictions`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the customer contact details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerContactsResponse 
    resource isolated function get customers/[string customerId]/contacts(GetCustomerContactsHeaders headers = {}, *GetCustomerContactsQueries queries) returns CustomerContactsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/contacts`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the relation customers
    #
    # + headers - Headers to be sent with the request 
    # + return - CustomerRelationshipsResponse 
    resource isolated function get customers/[string customerId]/relationships(GetCustomerRelationshipsHeaders headers = {}) returns CustomerRelationshipsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/relationships`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves customer details required for payment processing
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - PartyBasicDetailsResponse 
    resource isolated function get customers/[string customerId]/payments(GetPartyBasicDetailsHeaders headers = {}, *GetPartyBasicDetailsQueries queries) returns PartyBasicDetailsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/payments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the SWIFT address details for the customer.
    #
    # + customerId - Identifier of the customer
    # + addressId - Reference Id of address record
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerSwiftAddressResponse 
    resource isolated function get customers/[string customerId]/addresses/swiftAddresses/[string addressId](GetCustomerSwiftAddressHeaders headers = {}, *GetCustomerSwiftAddressQueries queries) returns CustomerSwiftAddressResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/swiftAddresses/${getEncodedUri(addressId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves customer charge for a specific customer.
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + return - CustomerChargeResponse 
    resource isolated function get customers/[string customerId]/charges(GetCustomerChargeHeaders headers = {}) returns CustomerChargeResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/charges`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Updates customer charge for a specific customer.
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerChargeResponse 
    resource isolated function put customers/[string customerId]/charges(http:Request request, UpdateCustomerChargeHeaders headers = {}, *UpdateCustomerChargeQueries queries) returns CustomerChargeResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/charges`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Creates customer charge for a specific customer.
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerChargeResponse 
    resource isolated function post customers/[string customerId]/charges(http:Request request, CreateCustomerChargeHeaders headers = {}, *CreateCustomerChargeQueries queries) returns CustomerChargeResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/charges`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves available list of customer sms communication addresses
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerPhoneAddressResponse 
    resource isolated function get customers/[string customerId]/addresses/smsAddresses(GetCustomerPhoneAddressHeaders headers = {}, *GetCustomerPhoneAddressQueries queries) returns CustomerPhoneAddressResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/smsAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates customer sms communication address
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerPhoneAddressResponse 
    resource isolated function post customers/[string customerId]/addresses/smsAddresses(http:Request request, CreateCustomerPhoneAddressHeaders headers = {}, *CreateCustomerPhoneAddressQueries queries) returns CustomerPhoneAddressResponse1|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/smsAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves available list of customer email communication addresses
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerEmailAddressResponse 
    resource isolated function get customers/[string customerId]/addresses/emailAddresses(GetCustomerEmailAddressHeaders headers = {}, *GetCustomerEmailAddressQueries queries) returns CustomerEmailAddressResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/emailAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates customer email communication address
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerEmailAddressResponse 
    resource isolated function post customers/[string customerId]/addresses/emailAddresses(http:Request request, CreateCustomerEmailAddressHeaders headers = {}, *CreateCustomerEmailAddressQueries queries) returns CustomerEmailAddressResponse1|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/emailAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves available list of customer print communication addresses
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerPrintAddressResponse 
    resource isolated function get customers/[string customerId]/addresses/printAddresses(GetCustomerPrintAddressHeaders headers = {}, *GetCustomerPrintAddressQueries queries) returns CustomerPrintAddressResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/printAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates customer print communication address
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerPrintAddressResponse 
    resource isolated function post customers/[string customerId]/addresses/printAddresses(http:Request request, CreateCustomerPrintAddressHeaders headers = {}, *CreateCustomerPrintAddressQueries queries) returns CustomerPrintAddressResponse1|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/addresses/printAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Updates customer sms communication address
    #
    # + customerAddressId - Identifier of the customer address table
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerPhoneAddressResponse 
    resource isolated function put customers/addresses/[string customerAddressId]/smsAddresses(http:Request request, UpdateCustomerPhoneAddressHeaders headers = {}, *UpdateCustomerPhoneAddressQueries queries) returns CustomerPhoneAddressResponse1|error {
        string resourcePath = string `/customers/addresses/${getEncodedUri(customerAddressId)}/smsAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes customer sms communication address
    #
    # + customerAddressId - Identifier of the customer address table
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerPhoneAddressResponse 
    resource isolated function delete customers/addresses/[string customerAddressId]/smsAddresses(http:Request request, DeleteCustomerPhoneAddressHeaders headers = {}, *DeleteCustomerPhoneAddressQueries queries) returns CustomerPhoneAddressResponse1|error {
        string resourcePath = string `/customers/addresses/${getEncodedUri(customerAddressId)}/smsAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->delete(resourcePath, request, httpHeaders);
    }

    # Updates customer email communication address
    #
    # + customerAddressId - Identifier of the customer address table
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerEmailAddressResponse 
    resource isolated function put customers/addresses/[string customerAddressId]/emailAddresses(http:Request request, UpdateCustomerEmailAddressHeaders headers = {}, *UpdateCustomerEmailAddressQueries queries) returns CustomerEmailAddressResponse1|error {
        string resourcePath = string `/customers/addresses/${getEncodedUri(customerAddressId)}/emailAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes customer email communication address
    #
    # + customerAddressId - Identifier of the customer address table
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerEmailAddressResponse 
    resource isolated function delete customers/addresses/[string customerAddressId]/emailAddresses(http:Request request, DeleteCustomerEmailAddressHeaders headers = {}, *DeleteCustomerEmailAddressQueries queries) returns CustomerEmailAddressResponse1|error {
        string resourcePath = string `/customers/addresses/${getEncodedUri(customerAddressId)}/emailAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->delete(resourcePath, request, httpHeaders);
    }

    # Updates customer print communication address
    #
    # + customerAddressId - Identifier of the customer address table
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerPrintAddressResponse 
    resource isolated function put customers/addresses/[string customerAddressId]/printAddresses(http:Request request, UpdateCustomerPrintAddressHeaders headers = {}, *UpdateCustomerPrintAddressQueries queries) returns CustomerPrintAddressResponse1|error {
        string resourcePath = string `/customers/addresses/${getEncodedUri(customerAddressId)}/printAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes customer print communication address
    #
    # + customerAddressId - Identifier of the customer address table
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerPrintAddressResponse 
    resource isolated function delete customers/addresses/[string customerAddressId]/printAddresses(http:Request request, DeleteCustomerPrintAddressHeaders headers = {}, *DeleteCustomerPrintAddressQueries queries) returns CustomerPrintAddressResponse1|error {
        string resourcePath = string `/customers/addresses/${getEncodedUri(customerAddressId)}/printAddresses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->delete(resourcePath, request, httpHeaders);
    }

    # Retrieves customer consents details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerConsentsResponse 
    resource isolated function get customers/[string customerId]/consents(GetCustomerConsentsHeaders headers = {}, *GetCustomerConsentsQueries queries) returns CustomerConsentsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/consents`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update FATCA customer supplementary information details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - FatcaCustomerResponse 
    resource isolated function put customers/[string customerId]/fatca(http:Request request, UpdateFatcaCustomerHeaders headers = {}, *UpdateFatcaCustomerQueries queries) returns FatcaCustomerResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/fatca`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Create FATCA customer supplementary information details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - FatcaCustomerResponse 
    resource isolated function post customers/[string customerId]/fatca(http:Request request, CreateFatcaCustomerHeaders headers = {}, *CreateFatcaCustomerQueries queries) returns FatcaCustomerResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/fatca`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves overdue settlements of customer or portfolio
    #
    # + customerId - Identifier of the customer
    # + portfolioId - Id of the portfolio or security account
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OverdueSettlementsResponse 
    resource isolated function get customers/[string customerId]/portfolios/[string portfolioId]/overdueSettlements(GetOverdueSettlementsHeaders headers = {}, *GetOverdueSettlementsQueries queries) returns OverdueSettlementsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/portfolios/${getEncodedUri(portfolioId)}/overdueSettlements`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves details of third party providers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OtherBanksToConnectToResponse 
    resource isolated function get customers/accountServicingProviders(GetOtherBanksToConnectToHeaders headers = {}, *GetOtherBanksToConnectToQueries queries) returns OtherBanksToConnectToResponse|error {
        string resourcePath = string `/customers/accountServicingProviders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves prospect details of customers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - ProspectCustomersResponse 
    resource isolated function get customers/prospects(GetProspectCustomersHeaders headers = {}, *GetProspectCustomersQueries queries) returns ProspectCustomersResponse|error {
        string resourcePath = string `/customers/prospects`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a prospect customer
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - ProspectCustomerResponse 
    resource isolated function post customers/prospects(http:Request request, CreateProspectCustomerHeaders headers = {}, *CreateProspectCustomerQueries queries) returns ProspectCustomerResponse|error {
        string resourcePath = string `/customers/prospects`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves the sales opportunities for specific customers
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerOpportunitiesResponse 
    resource isolated function get customers/[string customerId]/opportunities(GetCustomerOpportunitiesHeaders headers = {}, *GetCustomerOpportunitiesQueries queries) returns CustomerOpportunitiesResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/opportunities`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves process workflows for a specific customer
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerRequestsResponse 
    resource isolated function get customers/[string customerId]/requests(GetCustomerRequestsHeaders headers = {}, *GetCustomerRequestsQueries queries) returns CustomerRequestsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/requests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update a prospect customer
    #
    # + prospectId - Indicates the status of an onboarding customer. Status can be PROSPECT while onboarding and ACTIVE when the prospect becomes a Customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - ProspectCustomerResponse 
    resource isolated function put customers/prospects/[string prospectId](http:Request request, UpdateProspectCustomerHeaders headers = {}, *UpdateProspectCustomerQueries queries) returns ProspectCustomerResponse|error {
        string resourcePath = string `/customers/prospects/${getEncodedUri(prospectId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Retrieves alert requests details
    #
    # + customerId - Identifier of the customer
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - AlertRequestsResponse 
    resource isolated function get customers/[string customerId]/alertRequests(GetAlertRequestsHeaders headers = {}, *GetAlertRequestsQueries queries) returns AlertRequestsResponse|error {
        string resourcePath = string `/customers/${getEncodedUri(customerId)}/alertRequests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves list of party relationship details
    #
    # + partyId - Allows capturing of customers or person entities to be part of the relationship. If partyType is selected as Customer, then the system will allow only customer Ids to be captured into this field. If partyType is selected as Person or Entity, then system will allow only personEntity Ids to be captured into this field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - PartyRelationshipResponse 
    resource isolated function get relationships/[string partyId]/relations(GetPartyRelationshipHeaders headers = {}, *GetPartyRelationshipQueries queries) returns PartyRelationshipResponse1|error {
        string resourcePath = string `/relationships/${getEncodedUri(partyId)}/relations`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create log of customer static data update event from external party systems
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerStaticChangeResponse 
    resource isolated function post customers/staticDataUpdateEvents(http:Request request, CreateCustomerStaticChangeHeaders headers = {}, *CreateCustomerStaticChangeQueries queries) returns CustomerStaticChangeResponse|error {
        string resourcePath = string `/customers/staticDataUpdateEvents`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Returns the owner of the BIC and the channel through which this BIC is used.
    #
    # + bicId - Bank Identifier Code (BIC) of the financial institution
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - BicOwnersResponse 
    resource isolated function get customers/bankCodes/BICs/[string bicId]/owners(GetBicOwnersHeaders headers = {}, *GetBicOwnersQueries queries) returns BicOwnersResponse|error {
        string resourcePath = string `/customers/bankCodes/BICs/${getEncodedUri(bicId)}/owners`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Allows amendment of customer group purpose
    #
    # + groupPurposeId - Identifier of customer group purpose
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupPurposeResponse 
    resource isolated function put customers/groupPurposes/[string groupPurposeId](http:Request request, UpdateCustomerGroupPurposeHeaders headers = {}, *UpdateCustomerGroupPurposeQueries queries) returns CustomerGroupPurposeResponse|error {
        string resourcePath = string `/customers/groupPurposes/${getEncodedUri(groupPurposeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Allows creation of customer group purpose.
    #
    # + groupPurposeId - Identifier of customer group purpose
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupPurposeResponse 
    resource isolated function post customers/groupPurposes/[string groupPurposeId](http:Request request, CreateCustomerGroupPurposeHeaders headers = {}, *CreateCustomerGroupPurposeQueries queries) returns CustomerGroupPurposeResponse|error {
        string resourcePath = string `/customers/groupPurposes/${getEncodedUri(groupPurposeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Allows deletion of unapproved customer group purpose
    #
    # + groupPurposeId - Identifier of customer group purpose
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupPurposeResponse 
    resource isolated function delete customers/groupPurposes/[string groupPurposeId](http:Request request, DeleteCustomerGroupPurposeHeaders headers = {}, *DeleteCustomerGroupPurposeQueries queries) returns CustomerGroupPurposeResponse|error {
        string resourcePath = string `/customers/groupPurposes/${getEncodedUri(groupPurposeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->delete(resourcePath, request, httpHeaders);
    }

    # Allows authorization of customer group purpose
    #
    # + groupPurposeId - Identifier of customer group purpose
    # + headers - Headers to be sent with the request 
    # + return - CustomerGroupPurposeResponse 
    resource isolated function put customers/groupPurposes/[string groupPurposeId]/approvals(ApproveCustomerGroupPurposeHeaders headers = {}) returns CustomerGroupPurposeResponse|error {
        string resourcePath = string `/customers/groupPurposes/${getEncodedUri(groupPurposeId)}/approvals`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Allows cancellation of customer group purpose
    #
    # + groupPurposeId - Identifier of customer group purpose
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupPurposeResponse 
    resource isolated function delete customers/groupPurposes/[string groupPurposeId]/cancellations(http:Request request, CancelCustomerGroupPurposeHeaders headers = {}, *CancelCustomerGroupPurposeQueries queries) returns CustomerGroupPurposeResponse|error {
        string resourcePath = string `/customers/groupPurposes/${getEncodedUri(groupPurposeId)}/cancellations`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->delete(resourcePath, request, httpHeaders);
    }

    # Allows amendment of customer group
    #
    # + groupId - Unique ID of the group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupResponse 
    resource isolated function put customers/groups/[string groupId](http:Request request, UpdateCustomerGroupHeaders headers = {}, *UpdateCustomerGroupQueries queries) returns CustomerGroupResponse|error {
        string resourcePath = string `/customers/groups/${getEncodedUri(groupId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Allows creation of customer group
    #
    # + groupId - Unique ID of the group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupResponse 
    resource isolated function post customers/groups/[string groupId](http:Request request, CreateCustomerGroupHeaders headers = {}, *CreateCustomerGroupQueries queries) returns CustomerGroupResponse|error {
        string resourcePath = string `/customers/groups/${getEncodedUri(groupId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Allows deletion of unapproved customer group
    #
    # + groupId - Unique ID of the group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerGroupResponse 
    resource isolated function delete customers/groups/[string groupId](http:Request request, DeleteCustomerGroupHeaders headers = {}, *DeleteCustomerGroupQueries queries) returns CustomerGroupResponse|error {
        string resourcePath = string `/customers/groups/${getEncodedUri(groupId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->delete(resourcePath, request, httpHeaders);
    }

    # Allows authorization of customer group
    #
    # + groupId - Unique ID of the group
    # + headers - Headers to be sent with the request 
    # + return - CustomerGroupResponse 
    resource isolated function put customers/groups/[string groupId]/approvals(ApproveCustomerGroupHeaders headers = {}) returns CustomerGroupResponse|error {
        string resourcePath = string `/customers/groups/${getEncodedUri(groupId)}/approvals`;
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Retrieves the list of unapproved customer group purposes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - UnapprovedCustomerGroupPurposeResponse 
    resource isolated function get customers/groupPurposes/pendingApprovals(GetUnapprovedCustomerGroupPurposeHeaders headers = {}, *GetUnapprovedCustomerGroupPurposeQueries queries) returns UnapprovedCustomerGroupPurposeResponse|error {
        string resourcePath = string `/customers/groupPurposes/pendingApprovals`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the list of customer group purposes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerGroupPurposeResponse 
    resource isolated function get customers/groupPurposes(GetCustomerGroupPurposeHeaders headers = {}, *GetCustomerGroupPurposeQueries queries) returns CustomerGroupPurposeResponse1|error {
        string resourcePath = string `/customers/groupPurposes`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the list of unapproved customer groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - UnapprovedCustomerGroupResponse 
    resource isolated function get customers/groups/pendingApprovals(GetUnapprovedCustomerGroupHeaders headers = {}, *GetUnapprovedCustomerGroupQueries queries) returns UnapprovedCustomerGroupResponse|error {
        string resourcePath = string `/customers/groups/pendingApprovals`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the details of customer group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerGroupsResponse 
    resource isolated function get customers/groups(GetCustomerGroupsHeaders headers = {}, *GetCustomerGroupsQueries queries) returns CustomerGroupsResponse|error {
        string resourcePath = string `/customers/groups`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves customer closure request.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CustomerClosureResponse 
    resource isolated function get customers/customerClosures(GetCustomerClosureHeaders headers = {}, *GetCustomerClosureQueries queries) returns CustomerClosureResponse1|error {
        string resourcePath = string `/customers/customerClosures`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates customer closure request
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerClosureResponse 
    resource isolated function post customers/customerClosures(http:Request request, CreateCustomerClosureHeaders headers = {}, *CreateCustomerClosureQueries queries) returns CustomerClosureResponse|error {
        string resourcePath = string `/customers/customerClosures`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Allows amendment of customer closure request
    #
    # + customerClosureId - Identifier of customer closure request
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - CustomerClosureResponse 
    resource isolated function put customers/customerClosures/[string customerClosureId](http:Request request, UpdateCustomerClosureHeaders headers = {}, *UpdateCustomerClosureQueries queries) returns CustomerClosureResponse|error {
        string resourcePath = string `/customers/customerClosures/${getEncodedUri(customerClosureId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<anydata> headerValues = {...headers};
        headerValues["apikey"] = self.apiKeyConfig.apikey;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }
}
